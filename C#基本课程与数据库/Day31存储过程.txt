		事务后续
并发问题:如果有多个用户同时访问一个数据库,当他们的事务同时使用相同的数据时可能会发生问题
1.丢失更新:当两个或多个事务选择同一行,然后基于最初选定的值更新该行时,会发生丢失更新问题(前一个事务提交的结果有可能被另一个事务覆盖)
2.未确认的相关性(脏读):当第二个事务选择其他事务正在更新的行时,会发生未确认的相关性问题(事务正在更新,表示尚未完成,数据不是持久性数据,该数据还没有提交的)
3.不一致的分析(非重复读):当第二个事务多次访问同一行,而且每次读取不同的数据时,会发生不一致的分析问题.(事务第一次访问时是一个结果,在第二次)
4.幻像读:当对某行执行插入或删除操作,而该行属于某个事务正在读取的行的范围的时候,会发生幻像读问题(读取的结果可能是更新之前的,没有获取最新的数据)

并发问题:可能产生不合理数据或数据不完整

并发控制:用于解决并发问题的技术手段和方法
并发控制的方法有两种:
1.一是采用锁
2.一是采用事务的隔离优先级

锁是在多用户环境中解决并发问题对数据访问限制的一种机制
分类:
    1.动态锁:SQL Server自动处理并发问题,
    2.手动锁:通过手动控制锁定问题
    两种基本锁:
	2.1)共享锁:用于不修改数据的操作,如select
	           其他事务可以读取表,但不能修改[插入,更新,删除]
        2.2)排它锁:用于修改数据的操作,如insert ,update ,delete 其他事务不能进行任何操作
死锁:是一锁的一种现象,事务1请求事务2正在加资源,而事务2正在请求事务1正在加载的资源

 隔离级别用于解决并发问题的一种方法.包含四个级别
		脏读	不可重复读	幻象
 1.未提交读	可能	可能		可能
 2.提交读	避免	可能		可能	
 3.可重复读	避免	避免		可能	
 4.可串行读	避免	避免		避免


 ---------------------存储过程-----------------
存储过程是一个命名的存储在服务器上的预编译T-SQL语句集合
 说明:1.存储过程在创建及第一次执行或重新编译执行时,
     会经过解析/优化/编译的过程,而后将编译结果存储在内存中
      2.存储过程与C#语言中的方法类似,存储过程可以带参数,也可以返回结果,可以包含DML,变量逻辑控制语句等.	

存储过程分类:
1.系统存储过程
   1)由系统定义,,存储在master数据库中
   2)系统存储过程的名称都以'sp_'或'xp_'
2.用户自定义存储过程
   1)由用户在自己的数据库中定义的存储过程
   2)类似于用户自定函数






















